-- Community Phase 2: Friends & Followers
-- 15_friends_followers.sql

-- ENUMS
create type user_visibility as enum ('NO_VISIBILITY','FRIENDS_ONLY','FRIENDS_AND_FOLLOWERS','ANYONE');

-- PROFILES (assumes profiles table exists with user_id PK = auth.uid())
alter table profiles
  add column if not exists visibility user_visibility not null default 'ANYONE',
  add column if not exists geo_opt_in boolean not null default false,
  add column if not exists lat double precision,
  add column if not exists lng double precision,
  add column if not exists diet text,
  add column if not exists skill_level text,
  add column if not exists favorite_cuisine text;

-- FOLLOW (one-way)
create table if not exists user_follows (
  follower_id uuid not null references profiles(user_id) on delete cascade,
  followee_id uuid not null references profiles(user_id) on delete cascade,
  created_at timestamptz not null default now(),
  constraint user_follows_pkey primary key (follower_id, followee_id),
  constraint no_self_follow check (follower_id <> followee_id)
);
create index if not exists idx_user_follows_followee on user_follows(followee_id);

-- FRIEND INVITATIONS + FRIENDS (two-way)
create table if not exists friend_invitations (
  invitation_id bigint generated by default as identity primary key,
  inviter_id uuid not null references profiles(user_id) on delete cascade,
  invitee_id uuid not null references profiles(user_id) on delete cascade,
  note text,
  status text not null default 'PENDING', -- PENDING|ACCEPTED|DECLINED|CANCELED|EXPIRED
  created_at timestamptz not null default now(),
  responded_at timestamptz,
  constraint no_self_invite check (inviter_id <> invitee_id)
);
create index if not exists idx_friend_invitations_invitee on friend_invitations(invitee_id);

create table if not exists user_friends (
  user_id uuid not null references profiles(user_id) on delete cascade,
  friend_id uuid not null references profiles(user_id) on delete cascade,
  created_at timestamptz not null default now(),
  constraint user_friends_pkey primary key (user_id, friend_id),
  constraint symmetric_pair check (user_id <> friend_id)
);
create index if not exists idx_user_friends_friend on user_friends(friend_id);

-- DIRECT SHARES
create table if not exists recipe_direct_shares (
  share_id bigint generated by default as identity primary key,
  user_recipe_id bigint not null references user_recipes(user_recipe_id) on delete cascade,
  sender_id uuid not null references profiles(user_id) on delete cascade,
  recipient_id uuid not null references profiles(user_id) on delete cascade,
  message text,
  created_at timestamptz not null default now(),
  accepted boolean,
  accepted_at timestamptz
);
create index if not exists idx_rds_recipient on recipe_direct_shares(recipient_id);

-- VOTES
create table if not exists recipe_votes (
  user_recipe_id bigint not null references user_recipes(user_recipe_id) on delete cascade,
  voter_id uuid not null references profiles(user_id) on delete cascade,
  value smallint not null check (value in (-1,1)),
  created_at timestamptz not null default now(),
  constraint recipe_votes_pkey primary key (user_recipe_id, voter_id)
);
create index if not exists idx_recipe_votes_recipe on recipe_votes(user_recipe_id);

-- FEED EVENTS
create type feed_event_kind as enum (
  'FRIEND_REQUEST','FOLLOW_REQUEST','DIRECT_SHARE','GROUP_UPDATE',
  'BADGE_EARNED','BADGE_NUDGE','RECIPE_UPVOTES'
);

create table if not exists feed_events (
  event_id bigint generated by default as identity primary key,
  user_id uuid not null references profiles(user_id) on delete cascade, -- owner of feed
  kind feed_event_kind not null,
  payload jsonb not null,
  created_at timestamptz not null default now(),
  read_at timestamptz
);
create index if not exists idx_feed_events_user_created on feed_events(user_id, created_at desc);

-- REFERRALS for "Friends Referred" badge
create table if not exists user_referrals (
  referrer_id uuid not null references profiles(user_id) on delete cascade,
  referred_id uuid not null references profiles(user_id) on delete cascade,
  created_at timestamptz not null default now(),
  constraint user_referrals_pkey primary key (referrer_id, referred_id),
  constraint no_self_referral check (referrer_id <> referred_id)
);

-- PRIVACY VIEW HELPERS (materialized or SQL views as needed)
create or replace view v_relationships as
select
  me.user_id as me_id,
  other.user_id as other_id,
  exists(select 1 from user_friends f where (f.user_id = me.user_id and f.friend_id = other.user_id) or (f.user_id = other.user_id and f.friend_id = me.user_id)) as are_friends,
  exists(select 1 from user_follows fo where fo.follower_id = me.user_id and fo.followee_id = other.user_id) as i_follow_other,
  exists(select 1 from user_follows fo2 where fo2.follower_id = other.user_id and fo2.followee_id = me.user_id) as other_follows_me
from profiles me
cross join profiles other
where me.user_id <> other.user_id;

-- RLS (example policies; tighten as needed)
alter table user_follows enable row level security;
alter table friend_invitations enable row level security;
alter table user_friends enable row level security;
alter table recipe_direct_shares enable row level security;
alter table recipe_votes enable row level security;
alter table feed_events enable row level security;
alter table user_referrals enable row level security;

-- Policies
create policy "users can follow others (insert self as follower)" on user_follows
  for insert with check (auth.uid() = follower_id);
create policy "users see their follow relationships" on user_follows
  for select using (auth.uid() in (follower_id, followee_id));
create policy "users can unfollow" on user_follows
  for delete using (auth.uid() = follower_id);

create policy "invite friend (inviter = auth)" on friend_invitations
  for insert with check (auth.uid() = inviter_id);
create policy "see invites (inviter or invitee)" on friend_invitations
  for select using (auth.uid() in (inviter_id, invitee_id));
create policy "respond to invite (invitee only)" on friend_invitations
  for update using (auth.uid() = invitee_id);

create policy "see friendships (participant)" on user_friends
  for select using (auth.uid() in (user_id, friend_id));
create policy "create friendship (server func only)" on user_friends
  for insert with check (false);

create policy "see direct shares (sender or recipient)" on recipe_direct_shares
  for select using (auth.uid() in (sender_id, recipient_id));
create policy "create direct share (sender = auth)" on recipe_direct_shares
  for insert with check (auth.uid() = sender_id);

create policy "cast/see votes (owner or any viewer according to visibility; selection allowed for all auth)" on recipe_votes
  for select using (true);
create policy "vote insert/update self" on recipe_votes
  for all using (auth.uid() = voter_id) with check (auth.uid() = voter_id);

create policy "see own feed events" on feed_events
  for select using (auth.uid() = user_id);
create policy "insert feed events (server func)" on feed_events
  for insert with check (false);

create policy "see own referrals" on user_referrals
  for select using (auth.uid() in (referrer_id, referred_id));
create policy "insert referral (server func)" on user_referrals
  for insert with check (false);

-- RPCs (privacy-aware)
create or replace function can_view_profile(viewer uuid, owner uuid)
returns boolean language sql stable as $$
  with rel as (
    select
      p.visibility,
      exists(select 1 from user_friends f where (f.user_id = viewer and f.friend_id = owner) or (f.user_id = owner and f.friend_id = viewer)) as are_friends,
      exists(select 1 from user_follows fo where fo.follower_id = viewer and fo.followee_id = owner) as i_follow_other
    from profiles p where p.user_id = owner
  )
  select case
    when (select visibility from rel) = 'ANYONE' then true
    when (select visibility from rel) = 'FRIENDS_AND_FOLLOWERS' then (select are_friends or i_follow_other from rel)
    when (select visibility from rel) = 'FRIENDS_ONLY' then (select are_friends from rel)
    else false
  end;
$$;

-- helper to return anonymized name if not visible
create or replace function safe_display_name(viewer uuid, owner uuid, fallback text default 'Anonymous')
returns text language sql stable as $$
  select case when can_view_profile(viewer, owner) then coalesce(p.display_name, p.full_name) else fallback end
  from profiles p where p.user_id = owner;
$$;

-- "My Feed" aggregation RPC
create or replace function get_my_feed(p_user uuid, p_limit int default 50)
returns setof feed_events language sql stable as $$
  select * from feed_events
  where user_id = p_user
  order by created_at desc
  limit p_limit;
$$;

-- People-like-you: basic CF seed (starter heuristic)
create or replace function discover_people_like_you(p_user uuid, p_limit int default 20)
returns table(user_id uuid, score numeric) language sql stable as $$
  with me as (
    select diet, skill_level, favorite_cuisine from profiles where user_id = p_user
  )
  select p.user_id,
         (case when p.diet = (select diet from me) then 1 else 0 end
          + case when p.skill_level = (select skill_level from me) then 1 else 0 end
          + case when p.favorite_cuisine = (select favorite_cuisine from me) then 1 else 0 end)::numeric as score
  from profiles p
  where p.user_id <> p_user
  order by score desc nulls last
  limit p_limit;
$$;

-- Near Me discovery (geo_opt_in required)
create or replace function discover_near_me(p_user uuid, radius_km numeric default 50)
returns table(user_id uuid, distance_km numeric) language sql stable as $$
  with me as (
    select lat as mlat, lng as mlng from profiles where user_id = p_user and geo_opt_in = true
  )
  select p.user_id,
    (111.045 * acos( least(1.0, cos(radians((select mlat from me))) * cos(radians(p.lat)) *
        cos(radians(p.lng) - radians((select mlng from me))) + sin(radians((select mlat from me))) *
        sin(radians(p.lat))))) as distance_km
  from profiles p
  where p.user_id <> p_user and p.geo_opt_in = true
  and (select mlat from me) is not null
  and (111.045 * acos( least(1.0, cos(radians((select mlat from me))) * cos(radians(p.lat)) *
        cos(radians(p.lng) - radians((select mlng from me))) + sin(radians((select mlat from me))) *
        sin(radians(p.lat))))) <= radius_km
  order by distance_km asc;
$$;

-- Accept friend invitation function
create or replace function accept_friend_invitation(p_invitation_id bigint)
returns boolean language plpgsql security definer as $$
declare
  v_invitation record;
  v_inviter_id uuid;
  v_invitee_id uuid;
begin
  -- Get invitation details
  select inviter_id, invitee_id, status
  into v_invitation
  from friend_invitations
  where invitation_id = p_invitation_id;
  
  -- Check if invitation exists and is pending
  if not found then
    raise exception 'Invitation not found';
  end if;
  
  if v_invitation.status != 'PENDING' then
    raise exception 'Invitation is not pending';
  end if;
  
  -- Check if current user is the invitee
  if auth.uid() != v_invitation.invitee_id then
    raise exception 'Only the invitee can accept the invitation';
  end if;
  
  v_inviter_id := v_invitation.inviter_id;
  v_invitee_id := v_invitation.invitee_id;
  
  -- Update invitation status
  update friend_invitations
  set status = 'ACCEPTED', responded_at = now()
  where invitation_id = p_invitation_id;
  
  -- Create friendship (both directions)
  insert into user_friends (user_id, friend_id) values
    (v_inviter_id, v_invitee_id),
    (v_invitee_id, v_inviter_id)
  on conflict do nothing;
  
  -- Create feed events for both users
  insert into feed_events (user_id, kind, payload) values
    (v_inviter_id, 'FRIEND_REQUEST', jsonb_build_object(
      'type', 'accepted',
      'friend_id', v_invitee_id,
      'friend_name', (select safe_display_name(v_inviter_id, v_invitee_id))
    )),
    (v_invitee_id, 'FRIEND_REQUEST', jsonb_build_object(
      'type', 'accepted',
      'friend_id', v_inviter_id,
      'friend_name', (select safe_display_name(v_invitee_id, v_inviter_id))
    ));
  
  -- Create referral entry
  insert into user_referrals (referrer_id, referred_id)
  values (v_inviter_id, v_invitee_id)
  on conflict do nothing;
  
  return true;
end;
$$;

-- Decline friend invitation function
create or replace function decline_friend_invitation(p_invitation_id bigint)
returns boolean language plpgsql security definer as $$
begin
  -- Check if current user is the invitee
  if auth.uid() != (select invitee_id from friend_invitations where invitation_id = p_invitation_id) then
    raise exception 'Only the invitee can decline the invitation';
  end if;
  
  -- Update invitation status
  update friend_invitations
  set status = 'DECLINED', responded_at = now()
  where invitation_id = p_invitation_id;
  
  return true;
end;
$$;

-- Get user's friends and followers count
create or replace function get_user_social_stats(p_user_id uuid)
returns table(friends_count bigint, followers_count bigint, following_count bigint) language sql stable as $$
  select 
    (select count(*) from user_friends where user_id = p_user_id) as friends_count,
    (select count(*) from user_follows where followee_id = p_user_id) as followers_count,
    (select count(*) from user_follows where follower_id = p_user_id) as following_count;
$$;

-- Search profiles with privacy awareness
create or replace function search_profiles(p_query text, p_viewer_id uuid, p_limit int default 20)
returns table(user_id uuid, display_name text, full_name text, avatar_url text, is_visible boolean) language sql stable as $$
  select 
    p.user_id,
    case when can_view_profile(p_viewer_id, p.user_id) then p.display_name else 'Anonymous' end as display_name,
    case when can_view_profile(p_viewer_id, p.user_id) then p.full_name else 'Anonymous' end as full_name,
    case when can_view_profile(p_viewer_id, p.user_id) then p.avatar_url else null end as avatar_url,
    can_view_profile(p_viewer_id, p.user_id) as is_visible
  from profiles p
  where p.user_id != p_viewer_id
    and (
      case when can_view_profile(p_viewer_id, p.user_id) then
        (p.display_name ilike '%' || p_query || '%' or p.full_name ilike '%' || p_query || '%')
      else false end
    )
  order by 
    case when can_view_profile(p_viewer_id, p.user_id) then 0 else 1 end,
    p.display_name
  limit p_limit;
$$;
