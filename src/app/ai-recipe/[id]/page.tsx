'use client'

import { useState, useEffect } from 'react'
import { useParams, useRouter } from 'next/navigation'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { supabase } from '@/lib/supabase'
import { getCurrentUser } from '@/lib/auth'
import { 
  Clock, 
  Users, 
  ChefHat, 
  Star, 
  Plus, 
  Edit3, 
  Save,
  ArrowLeft,
  Sparkles
} from 'lucide-react'
import { sanitizeText } from '@/lib/sanitize'

interface AIRecipe {
  recipe_id: string
  title: string
  description?: string
  image_url?: string
  prep_time?: string
  cook_time?: string
  total_time?: string
  servings?: string
  difficulty?: string
  cuisine?: { name: string }
  meal_type?: { name: string }
  ingredients?: any[]
  instructions?: any[]
  nutrition?: any
  rating?: string
  source?: string
}

export default function AIRecipePage() {
  const params = useParams()
  const router = useRouter()
  const [recipe, setRecipe] = useState<AIRecipe | null>(null)
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [isEditing, setIsEditing] = useState(false)
  const [editedRecipe, setEditedRecipe] = useState<AIRecipe | null>(null)

  useEffect(() => {
    loadRecipe()
  }, [params.id])

  const loadRecipe = async () => {
    try {
      // For AI recipes, we'll get them from session storage or create a mock
      // In a real implementation, you might store AI recipes in a separate table
      const aiRecipes = JSON.parse(sessionStorage.getItem('aiRecipes') || '[]')
      const foundRecipe = aiRecipes.find((r: AIRecipe) => r.recipe_id === params.id)
      
      if (foundRecipe) {
        setRecipe(foundRecipe)
        setEditedRecipe(foundRecipe)
      } else {
        // Fallback: create a mock recipe for demonstration
        setRecipe({
          recipe_id: params.id as string,
          title: 'AI Generated Recipe',
          description: 'This recipe was generated by AI',
          ingredients: [],
          instructions: [],
          source: 'AI Generated'
        })
        setEditedRecipe({
          recipe_id: params.id as string,
          title: 'AI Generated Recipe',
          description: 'This recipe was generated by AI',
          ingredients: [],
          instructions: [],
          source: 'AI Generated'
        })
      }
    } catch (error) {
      console.error('Error loading AI recipe:', error)
    } finally {
      setLoading(false)
    }
  }

  const saveToCookbook = async () => {
    if (!recipe) return
    
    try {
      setSaving(true)
      const user = await getCurrentUser()
      if (!user) {
        router.push('/auth/signin')
        return
      }

      // Helper function to convert PT format to human readable
      const convertPTTime = (ptTime?: string) => {
        if (!ptTime) return null
        if (ptTime.startsWith('PT')) {
          const timeStr = ptTime.replace('PT', '')
          let hours = 0
          let minutes = 0
          
          const hourMatch = timeStr.match(/(\d+)H/)
          if (hourMatch) hours = parseInt(hourMatch[1])
          
          const minuteMatch = timeStr.match(/(\d+)M/)
          if (minuteMatch) minutes = parseInt(minuteMatch[1])
          
          if (hours > 0 && minutes > 0) {
            return `${hours}h ${minutes}m`
          } else if (hours > 0) {
            return `${hours}h`
          } else if (minutes > 0) {
            return `${minutes}m`
          }
        }
        return ptTime // Return as-is if not PT format
      }

      // Create user recipe from AI recipe
      const { data: userRecipe, error: recipeError } = await supabase
        .from('user_recipes')
        .insert({
          user_id: user.id,
          title: recipe.title,
          description: recipe.description,
          image_url: recipe.image_url,
          prep_time: convertPTTime(recipe.prep_time),
          cook_time: convertPTTime(recipe.cook_time),
          total_time: convertPTTime(recipe.total_time),
          servings: recipe.servings,
          difficulty: recipe.difficulty,
          cuisine_id: null, // AI recipes don't have cuisine mapping
          meal_type_id: null, // AI recipes don't have meal type mapping
          source_name: 'AI Generated'
        })
        .select()
        .single()

      if (recipeError) {
        console.error('Error saving AI recipe:', recipeError)
        return
      }

      // Save ingredients if they exist
      if (recipe.ingredients && recipe.ingredients.length > 0) {
        const ingredientInserts = recipe.ingredients.map((ingredient: any) => {
          // Handle different ingredient formats from AI
          let rawName = ''
          let amount = ''
          let unit = ''
          
          if (typeof ingredient === 'string') {
            rawName = ingredient
          } else if (ingredient.name) {
            rawName = ingredient.name
            amount = ingredient.amount || ''
            unit = ingredient.unit || ''
          } else if (ingredient.raw_name) {
            rawName = ingredient.raw_name
            amount = ingredient.amount || ''
            unit = ingredient.unit || ''
          } else {
            rawName = String(ingredient)
          }
          
          return {
            user_recipe_id: userRecipe.user_recipe_id,
            raw_name: rawName,
            amount: amount,
            unit: unit,
            ingredient_id: null // AI recipes don't have ingredient mapping
          }
        })

        const { error: ingredientsError } = await supabase
          .from('user_recipe_ingredients')
          .insert(ingredientInserts)

        if (ingredientsError) {
          console.error('Error saving ingredients:', ingredientsError)
        }
      }

      // Save instructions if they exist
      if (recipe.instructions && recipe.instructions.length > 0) {
        const stepInserts = recipe.instructions.map((instruction: any, index: number) => {
          let stepText = ''
          
          if (typeof instruction === 'string') {
            stepText = instruction
          } else if (instruction.text) {
            stepText = instruction.text
          } else {
            stepText = String(instruction)
          }
          
          return {
            user_recipe_id: userRecipe.user_recipe_id,
            step_number: index + 1,
            text: stepText
          }
        })

        const { error: stepsError } = await supabase
          .from('user_recipe_steps')
          .insert(stepInserts)

        if (stepsError) {
          console.error('Error saving instructions:', stepsError)
        }
      }

      // Redirect to the saved recipe
      router.push(`/recipe/${userRecipe.user_recipe_id}`)
    } catch (error) {
      console.error('Error saving AI recipe to cookbook:', error)
    } finally {
      setSaving(false)
    }
  }

  const handleEdit = () => {
    setIsEditing(true)
  }

  const handleSave = () => {
    if (editedRecipe) {
      setRecipe(editedRecipe)
      setIsEditing(false)
    }
  }

  const handleCancel = () => {
    setEditedRecipe(recipe)
    setIsEditing(false)
  }

  const formatTime = (timeStr?: string) => {
    if (!timeStr) return ''
    return timeStr.replace('PT', '').replace('H', 'h ').replace('M', 'm').trim()
  }

  if (loading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-center min-h-[400px]">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-orange-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading AI recipe...</p>
          </div>
        </div>
      </div>
    )
  }

  if (!recipe) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-4">Recipe Not Found</h1>
          <p className="text-gray-600 mb-6">The AI-generated recipe you're looking for could not be found.</p>
          <Button onClick={() => router.push('/finder')} variant="outline">
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Recipe Finder
          </Button>
        </div>
      </div>
    )
  }

  const currentRecipe = isEditing ? editedRecipe : recipe

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <Button 
          onClick={() => router.push('/finder')} 
          variant="outline" 
          className="mb-4"
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          Back to Recipe Finder
        </Button>
        
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-2">
              <Sparkles className="w-6 h-6 text-purple-600" />
              <Badge variant="secondary" className="bg-purple-100 text-purple-800">
                AI Generated
              </Badge>
            </div>
            {isEditing ? (
              <input
                type="text"
                value={currentRecipe?.title || ''}
                onChange={(e) => setEditedRecipe({...currentRecipe!, title: e.target.value})}
                className="text-3xl font-bold text-gray-900 bg-transparent border-b-2 border-orange-600 focus:outline-none focus:border-orange-800 w-full"
              />
            ) : (
              <h1 className="text-3xl font-bold text-gray-900">{recipe.title}</h1>
            )}
            {recipe.description && (
              <p className="text-gray-600 mt-2">{recipe.description}</p>
            )}
          </div>
          
          <div className="flex gap-2 ml-4">
            {isEditing ? (
              <>
                <Button onClick={handleSave} size="sm">
                  <Save className="w-4 h-4 mr-2" />
                  Save
                </Button>
                <Button onClick={handleCancel} variant="outline" size="sm">
                  Cancel
                </Button>
              </>
            ) : (
              <>
                <Button onClick={handleEdit} variant="outline" size="sm">
                  <Edit3 className="w-4 h-4 mr-2" />
                  Edit
                </Button>
                <Button onClick={saveToCookbook} disabled={saving} size="sm">
                  <Plus className="w-4 h-4 mr-2" />
                  {saving ? 'Saving...' : 'Save to Cookbook'}
                </Button>
              </>
            )}
          </div>
        </div>
      </div>

      {/* Recipe Info */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Image */}
          {recipe.image_url && (
            <Card>
              <CardContent className="p-0">
                <img
                  src={recipe.image_url}
                  alt={recipe.title}
                  className="w-full h-64 object-cover rounded-lg"
                />
              </CardContent>
            </Card>
          )}

          {/* Ingredients */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <ChefHat className="w-5 h-5 mr-2 text-orange-600" />
                Ingredients
              </CardTitle>
            </CardHeader>
            <CardContent>
              {recipe.ingredients && recipe.ingredients.length > 0 ? (
                <ul className="space-y-2">
                  {recipe.ingredients.map((ingredient: any, index: number) => (
                    <li key={index} className="flex items-start">
                      <span className="w-2 h-2 bg-orange-600 rounded-full mt-2 mr-3 flex-shrink-0"></span>
                      <span className="text-gray-700">
                        {typeof ingredient === 'string' 
                          ? ingredient 
                          : ingredient.name || ingredient.raw_name || `${ingredient.amount || ''} ${ingredient.unit || ''} ${ingredient.name || ''}`.trim()
                        }
                      </span>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500">No ingredients listed</p>
              )}
            </CardContent>
          </Card>

          {/* Instructions */}
          <Card>
            <CardHeader>
              <CardTitle>Instructions</CardTitle>
            </CardHeader>
            <CardContent>
              {recipe.instructions && recipe.instructions.length > 0 ? (
                <ol className="space-y-4">
                  {recipe.instructions.map((instruction: any, index: number) => (
                    <li key={index} className="flex">
                      <span className="flex-shrink-0 w-8 h-8 bg-orange-600 text-white rounded-full flex items-center justify-center text-sm font-semibold mr-4">
                        {index + 1}
                      </span>
                      <div className="text-gray-700">
                        {typeof instruction === 'string' 
                          ? instruction 
                          : instruction.text || instruction
                        }
                      </div>
                    </li>
                  ))}
                </ol>
              ) : (
                <p className="text-gray-500">No instructions provided</p>
              )}
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Recipe Details */}
          <Card>
            <CardHeader>
              <CardTitle>Recipe Details</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {recipe.prep_time && (
                <div className="flex items-center">
                  <Clock className="w-4 h-4 mr-2 text-gray-500" />
                  <span className="text-sm text-gray-600">Prep: {formatTime(recipe.prep_time)}</span>
                </div>
              )}
              {recipe.cook_time && (
                <div className="flex items-center">
                  <Clock className="w-4 h-4 mr-2 text-gray-500" />
                  <span className="text-sm text-gray-600">Cook: {formatTime(recipe.cook_time)}</span>
                </div>
              )}
              {recipe.total_time && (
                <div className="flex items-center">
                  <Clock className="w-4 h-4 mr-2 text-gray-500" />
                  <span className="text-sm text-gray-600">Total: {formatTime(recipe.total_time)}</span>
                </div>
              )}
              {recipe.servings && (
                <div className="flex items-center">
                  <Users className="w-4 h-4 mr-2 text-gray-500" />
                  <span className="text-sm text-gray-600">Serves: {recipe.servings}</span>
                </div>
              )}
              {recipe.difficulty && (
                <div className="flex items-center">
                  <ChefHat className="w-4 h-4 mr-2 text-gray-500" />
                  <span className="text-sm text-gray-600">Difficulty: {recipe.difficulty}</span>
                </div>
              )}
              {recipe.cuisine?.name && (
                <div className="flex items-center">
                  <span className="text-sm text-gray-600">Cuisine: {recipe.cuisine.name}</span>
                </div>
              )}
              {recipe.meal_type?.name && (
                <div className="flex items-center">
                  <span className="text-sm text-gray-600">Type: {recipe.meal_type.name}</span>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Nutrition */}
          {recipe.nutrition && (
            <Card>
              <CardHeader>
                <CardTitle>Nutrition</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2 text-sm">
                  {recipe.nutrition.calories && (
                    <div className="flex justify-between">
                      <span>Calories:</span>
                      <span>{recipe.nutrition.calories}</span>
                    </div>
                  )}
                  {recipe.nutrition.protein && (
                    <div className="flex justify-between">
                      <span>Protein:</span>
                      <span>{recipe.nutrition.protein}</span>
                    </div>
                  )}
                  {recipe.nutrition.carbohydrates && (
                    <div className="flex justify-between">
                      <span>Carbs:</span>
                      <span>{recipe.nutrition.carbohydrates}</span>
                    </div>
                  )}
                  {recipe.nutrition.fat && (
                    <div className="flex justify-between">
                      <span>Fat:</span>
                      <span>{recipe.nutrition.fat}</span>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </div>
  )
}