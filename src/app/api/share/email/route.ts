import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase-server'
import { generateRecipePDF } from '@/lib/pdf'
import { renderToBuffer } from '@react-pdf/renderer'
import nodemailer from 'nodemailer'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerClient()
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    const { recipeId, recipients, subject, message, recipeTitle } = await request.json()

    if (!recipeId || !recipients || !Array.isArray(recipients) || recipients.length === 0) {
      return NextResponse.json({ error: 'Recipe ID and recipients are required' }, { status: 400 })
    }

    if (!subject || !subject.trim()) {
      return NextResponse.json({ error: 'Email subject is required' }, { status: 400 })
    }

    // Get user profile for email masking
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('full_name, display_name')
      .eq('user_id', user.id)
      .single()

    if (profileError) {
      console.error('Error fetching user profile:', profileError)
      return NextResponse.json({ error: 'Failed to get user profile' }, { status: 500 })
    }

    // Load recipe data
    const { data: recipe, error: recipeError } = await supabase
      .from('user_recipes')
      .select(`
        *,
        cuisine:cuisines(name),
        meal_type:meal_types(name)
      `)
      .eq('user_recipe_id', recipeId)
      .eq('user_id', user.id)
      .single()

    if (recipeError) {
      return NextResponse.json({ error: 'Recipe not found' }, { status: 404 })
    }

    // Get ingredients and steps
    const { data: ingredients } = await supabase
      .from('user_recipe_ingredients')
      .select('amount, unit, raw_name')
      .eq('user_recipe_id', recipeId)

    const { data: steps } = await supabase
      .from('user_recipe_steps')
      .select('step_number, text')
      .eq('user_recipe_id', recipeId)
      .order('step_number')

    // Transform data for PDF generation
    const recipeForPDF = {
      title: recipe.title,
      description: recipe.description,
      image: recipe.image_url,
      prepTime: recipe.prep_time,
      cookTime: recipe.cook_time,
      totalTime: recipe.total_time,
      servings: recipe.servings,
      difficulty: recipe.difficulty,
      cuisine: recipe.cuisine?.name,
      ingredients: (ingredients || []).map((ingredient: any) => ({
        amount: ingredient.amount,
        unit: ingredient.unit,
        name: ingredient.raw_name || ''
      })),
      instructions: (steps || []).map(step => ({
        step: step.step_number,
        text: step.text
      })),
      source: recipe.source_name,
      sourceUrl: recipe.source_url
    }

    // Generate PDF
    const pdfDoc = generateRecipePDF(recipeForPDF)
    const pdfBuffer = await renderToBuffer(pdfDoc)

    // Create email transporter
    const transporter = nodemailer.createTransporter({
      host: process.env.SMTP_HOST || 'smtp.gmail.com',
      port: parseInt(process.env.SMTP_PORT || '587'),
      secure: false, // true for 465, false for other ports
      auth: {
        user: process.env.SMTP_USER || process.env.EMAIL_FROM,
        pass: process.env.SMTP_PASSWORD,
      },
    })

    const senderName = profile.full_name || profile.display_name || 'Recipe Chef User'
    const fromEmail = `"${senderName}" <${process.env.EMAIL_FROM || 'noreply@passionworksstudio.com'}>`

    // Send emails to all recipients
    const emailPromises = recipients.map(async (recipient: string) => {
      const mailOptions = {
        from: fromEmail,
        to: recipient,
        subject: subject,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #f97316;">Recipe Shared from Recipe Chef</h2>
            <p>Hello!</p>
            <p><strong>${senderName}</strong> has shared a recipe with you: <strong>"${recipe.title}"</strong></p>
            
            ${message ? `<div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <p style="margin: 0; font-style: italic;">"${message}"</p>
            </div>` : ''}
            
            <p>The recipe is attached as a PDF file for your convenience.</p>
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px;">
              <p>This email was sent via <a href="https://www.passionworksstudio.com" style="color: #f97316;">Passionworksstudio.com</a></p>
              <p>Recipe generated by Recipe Chef</p>
            </div>
          </div>
        `,
        attachments: [
          {
            filename: `${recipe.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`,
            content: pdfBuffer,
            contentType: 'application/pdf'
          }
        ]
      }

      return transporter.sendMail(mailOptions)
    })

    const results = await Promise.allSettled(emailPromises)
    
    const successful = results.filter(result => result.status === 'fulfilled').length
    const failed = results.filter(result => result.status === 'rejected').length

    if (failed > 0) {
      console.error('Some emails failed to send:', results.filter(r => r.status === 'rejected'))
    }

    return NextResponse.json({
      success: true,
      sentCount: successful,
      failedCount: failed,
      message: `Recipe sent to ${successful} recipient${successful > 1 ? 's' : ''}${failed > 0 ? `, ${failed} failed` : ''}`
    })

  } catch (error) {
    console.error('Email sharing error:', error)
    return NextResponse.json({ error: 'Failed to send recipe via email' }, { status: 500 })
  }
}
